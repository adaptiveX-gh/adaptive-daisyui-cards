<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SSE Streaming Test Client - Adaptive Cards Platform</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      background: white;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    h1 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 2em;
    }

    .subtitle {
      color: #666;
      font-size: 1.1em;
    }

    .controls {
      background: white;
      border-radius: 12px;
      padding: 25px;
      margin-bottom: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }

    input, select {
      width: 100%;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      transition: border 0.3s;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
    }

    .button-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 20px;
    }

    button {
      padding: 14px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    .btn-secondary {
      background: #f0f0f0;
      color: #333;
    }

    .btn-secondary:hover {
      background: #e0e0e0;
    }

    .btn-danger {
      background: #ff4757;
      color: white;
    }

    .btn-danger:hover {
      background: #ee5a6f;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .status {
      background: white;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      margin-bottom: 10px;
      background: #f8f9fa;
      border-radius: 8px;
    }

    .status-label {
      font-weight: 600;
      color: #555;
    }

    .status-value {
      font-family: 'Courier New', monospace;
      padding: 4px 12px;
      border-radius: 6px;
      font-size: 14px;
    }

    .status-connected {
      background: #d4edda;
      color: #155724;
    }

    .status-disconnected {
      background: #f8d7da;
      color: #721c24;
    }

    .status-streaming {
      background: #d1ecf1;
      color: #0c5460;
    }

    .events-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .events {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      max-height: 600px;
      overflow-y: auto;
    }

    .events h2 {
      margin-bottom: 15px;
      color: #667eea;
      font-size: 1.4em;
    }

    .event {
      background: #f8f9fa;
      border-left: 4px solid #667eea;
      padding: 12px;
      margin-bottom: 10px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }

    .event-skeleton { border-left-color: #6c757d; }
    .event-content { border-left-color: #17a2b8; }
    .event-style { border-left-color: #28a745; }
    .event-placeholder { border-left-color: #ffc107; }
    .event-image { border-left-color: #007bff; }
    .event-complete { border-left-color: #28a745; background: #d4edda; }
    .event-error { border-left-color: #dc3545; background: #f8d7da; }
    .event-progress { border-left-color: #6f42c1; }

    .event-meta {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 11px;
      color: #666;
    }

    .event-stage {
      font-weight: bold;
      text-transform: uppercase;
    }

    .event-data {
      margin-top: 8px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .cards {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .cards h2 {
      margin-bottom: 15px;
      color: #667eea;
      font-size: 1.4em;
    }

    .card-preview {
      background: #f8f9fa;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      transition: all 0.3s;
    }

    .card-preview.loading {
      border-color: #ffc107;
      animation: pulse 2s infinite;
    }

    .card-preview.complete {
      border-color: #28a745;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .card-id {
      font-size: 11px;
      color: #999;
      font-family: 'Courier New', monospace;
    }

    .card-content {
      margin-top: 10px;
    }

    .card-section {
      margin-bottom: 8px;
    }

    .section-label {
      font-weight: 600;
      color: #555;
      font-size: 12px;
      margin-bottom: 4px;
    }

    .section-value {
      color: #333;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 15px;
    }

    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .stat-label {
      font-size: 12px;
      opacity: 0.9;
    }

    @media (max-width: 768px) {
      .events-container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>SSE Streaming Test Client</h1>
      <p class="subtitle">Adaptive Cards Platform - Phase 3: Progressive Assembly</p>
    </div>

    <div class="controls">
      <div class="form-group">
        <label for="topic">Presentation Topic</label>
        <input type="text" id="topic" value="AI in Product Discovery" placeholder="Enter topic...">
      </div>

      <div class="form-group">
        <label for="cardCount">Number of Cards (1-20)</label>
        <input type="number" id="cardCount" value="6" min="1" max="20">
      </div>

      <div class="form-group">
        <label for="style">Presentation Style</label>
        <select id="style">
          <option value="professional">Professional</option>
          <option value="playful">Playful</option>
          <option value="minimal">Minimal</option>
        </select>
      </div>

      <div class="form-group">
        <label for="includeImages">
          <input type="checkbox" id="includeImages"> Include Images (async generation)
        </label>
      </div>

      <div class="form-group">
        <label for="streamDelay">Stream Delay (ms) - For Testing</label>
        <input type="number" id="streamDelay" value="200" min="0" max="2000" step="100">
      </div>

      <div class="button-group">
        <button class="btn-primary" onclick="startStream()">Start Streaming</button>
        <button class="btn-secondary" onclick="startDemo()">Demo Stream</button>
        <button class="btn-danger" onclick="stopStream()">Stop Stream</button>
        <button class="btn-secondary" onclick="clearAll()">Clear All</button>
      </div>
    </div>

    <div class="status">
      <h2>Connection Status</h2>
      <div class="status-row">
        <span class="status-label">Connection</span>
        <span class="status-value status-disconnected" id="connectionStatus">Disconnected</span>
      </div>
      <div class="status-row">
        <span class="status-label">Current Stage</span>
        <span class="status-value" id="currentStage">-</span>
      </div>
      <div class="status-row">
        <span class="status-label">Events Received</span>
        <span class="status-value" id="eventCount">0</span>
      </div>
    </div>

    <div class="stats">
      <div class="stat-card">
        <div class="stat-value" id="skeletonCount">0</div>
        <div class="stat-label">Skeleton</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="contentCount">0</div>
        <div class="stat-label">Content</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="styleCount">0</div>
        <div class="stat-label">Style</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="placeholderCount">0</div>
        <div class="stat-label">Placeholder</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="imageCount">0</div>
        <div class="stat-label">Image</div>
      </div>
    </div>

    <div class="events-container">
      <div class="events">
        <h2>Event Stream</h2>
        <div id="eventLog"></div>
      </div>

      <div class="cards">
        <h2>Card Preview</h2>
        <div id="cardPreviews"></div>
      </div>
    </div>
  </div>

  <script>
    let eventSource = null;
    let eventCount = 0;
    let stageCounts = {
      skeleton: 0,
      content: 0,
      style: 0,
      placeholder: 0,
      image: 0
    };
    let cards = new Map();

    function updateStatus(status, stage = '-') {
      document.getElementById('connectionStatus').textContent = status;
      document.getElementById('connectionStatus').className =
        `status-value ${status === 'Connected' ? 'status-connected' : status === 'Streaming' ? 'status-streaming' : 'status-disconnected'}`;
      document.getElementById('currentStage').textContent = stage;
    }

    function updateEventCount() {
      document.getElementById('eventCount').textContent = eventCount;
    }

    function updateStageCounts() {
      document.getElementById('skeletonCount').textContent = stageCounts.skeleton;
      document.getElementById('contentCount').textContent = stageCounts.content;
      document.getElementById('styleCount').textContent = stageCounts.style;
      document.getElementById('placeholderCount').textContent = stageCounts.placeholder;
      document.getElementById('imageCount').textContent = stageCounts.image;
    }

    function logEvent(event, data) {
      eventCount++;
      updateEventCount();

      const eventLog = document.getElementById('eventLog');
      const eventEl = document.createElement('div');
      eventEl.className = `event event-${event.stage || event}`;

      const timestamp = new Date().toLocaleTimeString();
      const stage = event.stage || event;

      stageCounts[stage] = (stageCounts[stage] || 0) + 1;
      updateStageCounts();

      eventEl.innerHTML = `
        <div class="event-meta">
          <span class="event-stage">${stage}</span>
          <span class="event-time">${timestamp}</span>
        </div>
        <div class="event-data">${JSON.stringify(data, null, 2)}</div>
      `;

      eventLog.insertBefore(eventEl, eventLog.firstChild);
      updateStatus('Streaming', stage);
    }

    function updateCard(cardId, updates) {
      if (!cards.has(cardId)) {
        cards.set(cardId, {
          id: cardId,
          sections: {},
          complete: false
        });
      }

      const card = cards.get(cardId);
      Object.assign(card, updates);

      renderCards();
    }

    function renderCards() {
      const container = document.getElementById('cardPreviews');
      container.innerHTML = '';

      for (const [cardId, card] of cards.entries()) {
        const cardEl = document.createElement('div');
        cardEl.className = `card-preview ${card.complete ? 'complete' : 'loading'}`;

        let sectionsHTML = '';
        for (const [section, value] of Object.entries(card.sections)) {
          sectionsHTML += `
            <div class="card-section">
              <div class="section-label">${section}</div>
              <div class="section-value">${value}</div>
            </div>
          `;
        }

        cardEl.innerHTML = `
          <div class="card-id">${cardId}</div>
          <div class="card-content">
            ${sectionsHTML || '<em>Loading...</em>'}
          </div>
        `;

        container.appendChild(cardEl);
      }
    }

    function startStream() {
      if (eventSource) {
        stopStream();
      }

      const topic = document.getElementById('topic').value;
      const cardCount = parseInt(document.getElementById('cardCount').value);
      const style = document.getElementById('style').value;
      const includeImages = document.getElementById('includeImages').checked;
      const streamDelay = parseInt(document.getElementById('streamDelay').value);

      const apiUrl = 'http://localhost:3000';
      const endpoint = `${apiUrl}/api/presentations/stream`;

      updateStatus('Connecting', '-');

      fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream'
        },
        body: JSON.stringify({
          topic,
          cardCount,
          style,
          includeImages,
          streamDelay
        })
      }).then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        updateStatus('Connected', 'waiting');

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        function readStream() {
          reader.read().then(({ done, value }) => {
            if (done) {
              updateStatus('Disconnected', 'complete');
              return;
            }

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.substring(6));
                  handleMessage(data);
                } catch (e) {
                  console.error('Failed to parse SSE data:', e);
                }
              }
            }

            readStream();
          });
        }

        readStream();
      }).catch(error => {
        console.error('Stream error:', error);
        updateStatus('Error', error.message);
        alert(`Failed to start stream: ${error.message}`);
      });
    }

    function startDemo() {
      if (eventSource) {
        stopStream();
      }

      const apiUrl = 'http://localhost:3000';
      const delay = document.getElementById('streamDelay').value;
      const endpoint = `${apiUrl}/api/stream/demo?delay=${delay}`;

      updateStatus('Connecting', '-');

      fetch(endpoint, {
        method: 'GET',
        headers: {
          'Accept': 'text/event-stream'
        }
      }).then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        updateStatus('Connected', 'demo');

        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        function readStream() {
          reader.read().then(({ done, value }) => {
            if (done) {
              updateStatus('Disconnected', 'complete');
              return;
            }

            const chunk = decoder.decode(value);
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.substring(6));
                  handleMessage(data);
                } catch (e) {
                  console.error('Failed to parse SSE data:', e);
                }
              }
            }

            readStream();
          });
        }

        readStream();
      }).catch(error => {
        console.error('Stream error:', error);
        updateStatus('Error', error.message);
        alert(`Failed to start demo: ${error.message}`);
      });
    }

    function handleMessage(data) {
      logEvent(data, data);

      switch (data.stage) {
        case 'skeleton':
          if (data.cards) {
            data.cards.forEach(card => {
              updateCard(card.id, {
                layout: card.layout,
                type: card.type
              });
            });
          }
          break;

        case 'content':
          if (data.cardId && data.section) {
            const card = cards.get(data.cardId);
            if (card) {
              card.sections[data.section] = data.content;
              renderCards();
            }
          }
          break;

        case 'style':
          if (data.cardId) {
            updateCard(data.cardId, {
              styles: data.styles
            });
          }
          break;

        case 'placeholder':
          if (data.cardId) {
            updateCard(data.cardId, {
              placeholder: data.placeholder
            });
          }
          break;

        case 'image':
          if (data.cardId) {
            updateCard(data.cardId, {
              image: data.image
            });
          }
          break;

        case 'error':
          alert(`Error: ${data.error.message}`);
          break;
      }
    }

    function stopStream() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
      updateStatus('Disconnected', '-');
    }

    function clearAll() {
      stopStream();
      document.getElementById('eventLog').innerHTML = '';
      document.getElementById('cardPreviews').innerHTML = '';
      eventCount = 0;
      stageCounts = {
        skeleton: 0,
        content: 0,
        style: 0,
        placeholder: 0,
        image: 0
      };
      cards.clear();
      updateEventCount();
      updateStageCounts();
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', stopStream);
  </script>
</body>
</html>
